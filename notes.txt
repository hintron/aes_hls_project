Building BoringSSL in Windows:
==================================
See https://boringssl.googlesource.com/boringssl/+/HEAD/BUILDING.md

mkdir build
cd build
cmake -GNinja ..
ninja

I installed Active State Perl, Ninja, Yasm, and Go, and added them to system PATH. Cmake was already installed.
Yasm and Ninja were just executables that I downloaded and placed in their own folder in C:\Program Files\.

When I tried initially building BoringSSL in a windows powershell, cmake didn't know how to find cl. I could either open up a developer console, or I can add cl to a normal powershell terminal.
See http://stackoverflow.com/questions/84404/using-visual-studios-cl-from-a-normal-command-line

This time, things failed. It looks like a GCC-related ld executable is being executed instead of a MSVC ld executable. So I removed from my path:

    C:\TDD-GCC-64\bin
    C:\Program Files\Haskell Platform\8.0.1\mingw\bin

This didn't do much. So I figured it might be because there is a space in the path to BoringSSL ("Winter 2017"). I moved BoringSSL to C:\crypto\ and tried it there. I also deleted the cmake generated files in build.

This time, I got farther in the build process before I encountered errors.
It said it could not find the assembler. The BoringSSL build instructions say to set CMAKE_ASM_NASM_COMPILER.
The error output said to set an environmental variable "ASM_NASM" or to set the cmake cache entry
CMAKE_ASM_NASM_COMPILER to the full path of yasm, or just the name of yasm if yasm is in the path.

Since I already added "C:\Program Files\yasm" to the path, I just set ASM_NASM to yasm-1.3.0-win64.exe.

Finally, it worked! (at least, the "cmake -GNinja .." command)

Now running "ninja"... it worked! Everything was built.

Looks like I can point to the ssl library at C:\crypto\boringssl\build\ssl and the crypto library at C:\crypto\boringssl\build\crypto

Creating a program
============================
I Created a simple standalone program called aes_test.cpp.
I used it to test out using the AES blocks in the BorinsSSL library

*Basic cl syntax: https://msdn.microsoft.com/en-us/library/610ecb4h.aspx
*Specify include dir: https://msdn.microsoft.com/en-us/library/73f9s62w.aspx
*Specify library dir (Linker option, not cl option!): https://msdn.microsoft.com/en-us/library/1xhzskbe.aspx
*Link Warning 4098 (verbose:lib option): http://stackoverflow.com/questions/3007312/resolving-lnk4098-defaultlib-msvcrt-conflicts-with
*Info on MVSC CRT (C runtime library): https://msdn.microsoft.com/en-us/library/abx4dbyh.aspx
*Warning C4577 "noexcept" - specify /EHsc option by suggestion from the compiler. See https://msdn.microsoft.com/en-us/library/1deeycx5.aspx
*Link Error 2019 Fix: Add in /NODEFAULTLIB:MSVCRTD linker option by suggestion from the compiler

cd to directory containing aes_testbench.cpp

    cl /EHsc /I C:\crypto\boringssl\include aes_test.cpp crypto.lib /link /LIBPATH:C:\crypto\boringssl\build\crypto /verbose:lib /NODEFAULTLIB:MSVCRTD

It appears that OpenSSL stores things in arrays in big-endian (printable) format.
See http://stackoverflow.com/a/9455607/1416379


Create a testbench
===================================
I created a wrapper function for the AES block, so I can target it as the top-level function in Vivado HLS.

To compile:

    cl /EHsc /I C:\crypto\boringssl\include aes_testbench.cpp aes_256_wrapper.cpp crypto.lib /link /LIBPATH:C:\crypto\boringssl\build\crypto /verbose:lib /NODEFAULTLIB:MSVCRTD

Synthesize in Vivado HLS
==========================
To specify where the BoringSSL headers are,
go to Project -> Project Settings -> Synthesis, click aes_256_wrapper.cpp, and click Edit CFLAGS...
Paste the following in:

    -I C:/crypto/boringssl/include

It looks like these CFLAGS are only for compilation, not linking.
Pasting this in did nothing to add in a library, since the linking options are ignored in CFLAGS:

    -L C:/crypto/boringssl/crypto -lcrypto

See pg. 28 of the Vivado HLS guide.
See also https://gcc.gnu.org/onlinedocs/gcc/Directory-Options.html#Directory-Options
Look at -I dir, -Ldir
This will probably also work for Simulation.

Other failed methods:
Right click the project in the Explorer on the right side and click Properties.
Under C/C++ General -> Paths and Symbols, you can add in include paths, library paths, and specify libraries.
However, it doesn't seem to "stick," even after pressing the Apply button. They will get removed whenever the next synthesis runs... ???

I ended up adding aes.c as a source file.
I also added the boringssl include option to the aes.c file and it got farther.
However, it complained that some of the functions had empty bodies.
When I looked at the code, I realized that it thought that OPENSSL_NO_ASM was not defined, and maybe OPENSSL_ARM
is defined, because the board might have an arm processor. But it was still failing. Maybe there is a way to
offload the AES computation to a special ARM unit. Either way, for the purposes of HLS, I want the AES to be done
in software so it can be translated to hardware. So I needed to define OPENSSL_NO_ASM. I did this by adding the
following to the CFLAGS for aes.c (also see pg.28 of the Vivado HLS Guide):

    -DOPENSSL_NO_ASM

This seemed to use the correct portion of code in aes.c and got the synthesis further along.

Update: So I ended up modifying aes.c to not include unused code.
I took out all asserts and assert-like code that checked if pointers exist, since HLS didn't like that.

Update: I ended up gating the asserts and aes code with a define called HLS_SYNTHESIS. So instead of
adding -DOPENSSL_NO_ASM, add this to aes.c CFLAGS in Vivado HLS:

    -DHLS_SYNTHESIS

I've been running into this problem with the AES code, since it uses arrays like pointers:

    ERROR: [SYNCHK 200-61] ../../../../../../../../crypto/boringssl/crypto/aes/aes.c:587: unsupported memory access on variable 'key' which is (or contains) an array with unknown size at compile time.

See pg. 330 of the Vivado HLS guide.
The problem was that functions like AES_encrypt() were passed pointers to arrays, but Vivado did not
know how many bytes the arrays were and refused to synthesize.
The solution was to simple change them from pointers to arrays, e.g. *in to in[16].

set_decrypt_key had unknown latency. Clicking the question marks pulled up this link:
https://www.xilinx.com/support/answers/50502.html
The problem is that AES_set_decrypt_key() has for loops with variables in the conditional.
Though it synthesizes, it prevents it from reporting on the loop latency, since it doesn't
know the number of iterations.
See pg. 470 of Vivado HLS Guide for the set_directive_loop_tripcount

I hosted the Boring SSL code that I modified here:
https://github.com/hintron/boring_ssl_hls

The testbench and aes wrapper files are stored here:
https://bitbucket.org/kolob/hls_aes_project/

The part number is xc7z010clg400-1.
